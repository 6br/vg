package vg;


// graphs are collections of nodes and edges
// they can represent subgraphs of larger graphs
// or be wholly-self-sufficient
// ... but remember protobuf memory limits of 67108864 bytes
message Graph {
    repeated Node node = 1;
    repeated Edge edge = 2;
    //repeated Alignment alignments = 3;
}

// Nodes store sequence data and also links to other nodes.
// The graph is doubly-linked via IDs in prev/next fields in the Node objects.

message Node {
    // sequence, name, and id
    optional string sequence = 1;
    optional string name = 2;
    // an id is required; a node is an element in a graph identified by an id
    required int64 id = 3;
    // annotations
    optional double quality = 4;
    optional int32 coverage = 5;
    // user-defined annotations, possibly a string, possibly more binary data
    optional bytes data = 6;
}

// Edges describe linkages between nodes. They are directed: from=prev, to=next.
// As in GFA, they can possibly describe an overlap structure between nodes
message Edge {
    // ID of upstream node
    required int64 from = 1;
    // ID of downstream node
    required int64 to = 2;
    // annotations
    optional bytes data = 3;
}

// Edit operations describe positional mapping between two sequences.
// They are conceptually equivalent to SAM cigars

message Edit {
    required int32 length = 1;
    enum Type {
        MATCH = 0;
        INSERTION = 1;
        DELETION = 2;
        MISMATCH = 3;
        SOFTCLIP = 4;
    }
    required Type type = 2;
    optional string sequence = 3;
}

// A node mapping defines the relationship between a target (node)
// and query (sequence or other node we are relating to the target).

message Mapping {
    required int64 node_id = 1;
    repeated Edit edit = 2;
    // todo should there be a position here?
}

// Paths can represent:
//    - haplotypes as series of node mappings that have no edit information
//    - mappings of reads, or alignments, by including edits
//    - relationships between nodes

message Path {
    optional int32 target_position = 1;
    repeated Mapping mapping = 2;
}

// Alignments link query strings or reads to paths.

message Alignment {
    optional string sequence = 1;
    optional Path path = 2;
    optional string name = 3;
    optional string quality = 4;
    optional int32 mapping_quality = 5;
    optional int32 score = 6;
    optional int32 query_position = 7;
    optional bytes data = 8;
}

// used to specify kmer matches against a given node
// the context of this is dependent on implementation, use in db, etc.
message KmerMatch {
    optional string sequence = 1;
    optional int64 node_id = 2;
    optional sint32 position = 3;
}
