syntax = "proto3";

package vg;

// *Graphs* are collections of nodes and edges
// They can represent subgraphs of larger graphs
// or be wholly-self-sufficient.
// Protobuf memory limits of 67108864 bytes mean we typically keep the size
// of them small generating graphs as collections of smaller subgraphs.
//
message Graph {
    repeated Node node = 1;
    repeated Edge edge = 2;
    repeated Path path = 3;
    map<string, Info> info = 4;
}

// *Nodes* store sequence data and also links to other nodes.
// The graph is doubly-linked via IDs in prev/next fields in the Node objects.
//
message Node {
    optional string sequence = 1;   // sequence
    optional string name = 2;  // a name provides an identifier
    optional int64 id = 3;     // ids are critical, and unique within a graph
    optional bytes data = 4;   // arbitrary data
    map<string, Info> info = 5;
}

// *Edges* describe linkages between nodes. They are directed: from=prev, to=next.
//
message Edge {
    optional int64 from = 1; // ID of upstream node
    optional int64 to = 2;   // ID of downstream node
    optional bool from_start = 3; // if the edge leaves from the 5' (start) of a node
    optional bool to_end = 4; // if the edge goes to the 3' (end) of a node
    optional bytes data = 5; // arbitrary data
    map<string, Info> info = 6;
}

// info fields can be used to annotate objects in the graph
message Info {
    optional string id = 1;
    optional string str = 2;
    optional int64 int = 3;
    optional bytes data = 4;
    map<string, Info> info = 5;
}

// *Edits* describe how to generate a new string from elements
// in the graph. To determine the new string, just walk the series of edits,
// stepping from_length distance in the basis node, and to_length in the
// novel element, replacing from_length in the basis node with the sequence.
//
// *matches* from_length == to_length
// *snps* from_length == to_length; sequence = alt
// *deletions* from_length > to_length; sequence may be unset or empty
// *insertions* from_length < to_length; sequence contains relative insertion
// *skip* from_length == 0, to_length > 0; implies "soft clip" or sequence skip
//
message Edit {
    optional int32 from_length = 1; // length in target/ref
    optional int32 to_length = 2; // length in read/alt
    optional string sequence = 3;
    map<string, Info> info = 4;
}

// A Mapping defines the relationship between a node in system and another entity.
// An empty edit list implies complete match.
//
message Mapping {
    optional Position position = 1;
    repeated Edit edit = 2; // series of edit to transform to region in read/alt
    optional bool is_reverse = 3; // does the mapping go from the end of the node to the start
    map<string, Info> info = 4;
}

// A position in the graph is a pair of node and offset
//
message Position {
    optional int64 node_id = 1;
    optional int64 offset = 2;
    map<string, Info> info = 3;
}

// Paths are walks through nodes defined by a series of edits.
// They can be used to represent:
//    - haplotypes
//    - mappings of reads, or alignments, by including edits
//    - relationships between nodes
//    - annotations from other data sources, such as:
//          genes, exons, motifs, transcripts, peaks
//
message Path {
    optional string name = 1;
    repeated Mapping mapping = 2;
    map<string, Info> info = 3;
}

// Alignments link query strings, such as other genomes or reads, to paths.
//
message Alignment {
    optional string sequence = 1;
    optional Path path = 2;
    optional string name = 3;
    optional bytes quality = 4;
    optional int32 mapping_quality = 5;
    optional int32 score = 6;
    optional int32 query_position = 7;
    optional bool is_reverse = 8; // true if original sequence lies in the 3'->5' orientation
    optional string sample_name = 9;
    optional string read_group = 10;
    optional Alignment fragment_prev = 11; // e.g. contains an alignment with only a name, or only a graph mapping position
    optional Alignment fragment_next = 12; // same thing for next in fragment
    optional bytes data = 13;
    map<string, Info> info = 14;
}

// Fragments represent the library fragments that yield pairs of alignments
// or possibly a series of small alignments generated by a strobed read
message Fragment {
    repeated Alignment alignment = 1;
}

// used to serialize kmer matches
message KmerMatch {
    optional string sequence = 1;
    optional int64 node_id = 2;
    optional sint32 position = 3;
}
