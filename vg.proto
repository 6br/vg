package vg;


message Graph {
    optional int64 current_id = 1;
    repeated Node node = 2;
    repeated Edge edge = 3;
}

// Nodes store sequence data and also links to other nodes.
// The graph is doubly-linked via IDs in prev/next fields in the Node objects.

message Node {
    required string sequence = 1;
    optional string name = 2;
    required int64 id = 3;
    // annotations
    optional double quality = 4;
    optional int32 coverage = 5;
    optional bytes data = 6;
}

// Edges describe linkages between nodes. They are directed: from=prev, to=next.
// As in GFA, they can possibly describe an overlap structure between nodes
message Edge {
    // ID of upstream node
    required int64 from = 1;
    // ID of downstream node
    required int64 to = 2;
    // annotations
    optional bytes data = 3;
}

// Edit operations describe positional mapping between two sequences.
// They are conceptually equivalent to SAM cigars

message Edit {
    required int32 length = 1;
    enum Type {
        MATCH = 0;
        INSERTION = 1;
        DELETION = 2;
        MISMATCH = 3;
        SOFTCLIP = 4;
    }
    required Type type = 2;
    optional string sequence = 3;
}

// A node mapping defines the relationship between a target (node)
// and query (sequence or other node we are relating to the target).

message Mapping {
    required int64 node_id = 1;
    repeated Edit edit = 2;
    // todo should there be a position here?
}

// Paths can represent:
//    - haplotypes as series of node mappings that have no edit information
//    - mappings of reads, or alignments, by including edits
//    - relationships between nodes

message Path {
    repeated Mapping mapping = 1;
}

// Alignments link query strings or reads to paths.

message Alignment {
    optional string sequence = 1;
    optional Path path = 2;
    optional string name = 3;
    optional bytes quality = 4;
    optional int32 mapping_quality = 5;
    optional int32 score = 6;
    optional int32 target_position = 7;
    optional int32 query_position = 8;
    optional bytes data = 9;
}

// used to specify a match starting a specified position
// the context of this is dependent on implementation, use in db, etc.

message Match {
    optional int64 node_id = 1;
    optional int32 position = 2;
}

message Matches {
    repeated Match match = 1;
}
